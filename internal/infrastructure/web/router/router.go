package router

import (
	"btc-ltp-service/internal/domain/interfaces"
	"btc-ltp-service/internal/infrastructure/config"
	"btc-ltp-service/internal/infrastructure/metrics"
	"btc-ltp-service/internal/infrastructure/ratelimit"
	"btc-ltp-service/internal/infrastructure/web/handlers"
	"btc-ltp-service/internal/infrastructure/web/middleware"
	"net/http"

	_ "btc-ltp-service/docs" // Import docs for swagger

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	httpSwagger "github.com/swaggo/http-swagger"
)

// Router encapsulates route configuration
type Router struct {
	priceService    interfaces.PriceService
	supportedPairs  []string
	rateLimitConfig config.RateLimitConfig
}

// NewRouter creates a new router instance
func NewRouter(priceService interfaces.PriceService, supportedPairs []string, rateLimitConfig config.RateLimitConfig) *Router {
	return &Router{
		priceService:    priceService,
		supportedPairs:  supportedPairs,
		rateLimitConfig: rateLimitConfig,
	}
}

// SetupRoutes configures all application routes
func (r *Router) SetupRoutes() http.Handler {
	// Create main router
	mainRouter := mux.NewRouter()

	// Create handlers
	ltpHandler := handlers.NewLTPHandler(r.priceService, r.supportedPairs)
	healthHandler := handlers.NewHealthHandler(r.priceService)

	// Swagger UI documentation (without rate limiting)
	// Swagger UI at "/swagger/". Serves `doc.json` generated by swag.
	mainRouter.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // Specification
	)).Methods("GET")

	// Legacy redirect: /docs -> /swagger/index.html
	mainRouter.HandleFunc("/docs", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/swagger/index.html", http.StatusMovedPermanently)
	}).Methods("GET")

	// Prometheus metrics endpoint (without rate limiting)
	mainRouter.Handle("/metrics", promhttp.Handler()).Methods("GET")

	// Health checks (without rate limiting)
	mainRouter.HandleFunc("/health", healthHandler.Health).Methods("GET")
	mainRouter.HandleFunc("/ready", healthHandler.Ready).Methods("GET")

	// API routes (without applying rate limiting here yet)
	apiRouter := mainRouter.PathPrefix("/api/v1").Subrouter()

	// LTP endpoints
	apiRouter.HandleFunc("/ltp", ltpHandler.GetLTP).Methods("GET")
	apiRouter.HandleFunc("/ltp/refresh", ltpHandler.RefreshPrices).Methods("POST")
	apiRouter.HandleFunc("/ltp/cached", ltpHandler.GetCachedPrices).Methods("GET")

	// Apply middlewares by layer:
	// 1. For API routes: Rate limiting + all middlewares
	// 2. For docs/health routes: Only basic middlewares

	// Apply rate limiting ONLY to API subrouter
	rateLimitMiddleware := ratelimit.NewRateLimitMiddlewareWithConfig(r.rateLimitConfig)

	// Wrap ONLY the API subrouter with rate limiting
	rateLimitedAPIRouter := rateLimitMiddleware.Handler(apiRouter)

	// Replace the API subrouter with the rate-limited version
	mainRouter.PathPrefix("/api/v1").Handler(rateLimitedAPIRouter)

	// Apply global middlewares (without rate limiting)
	handler := middleware.RequestTracingMiddleware(mainRouter)
	handler = metrics.HTTPMetricsMiddleware(handler)
	handler = middleware.LoggingMiddleware(handler)
	handler = middleware.CORSMiddleware(handler)

	return handler
}

// GetHandler returns the configured HTTP handler
func (r *Router) GetHandler() http.Handler {
	return r.SetupRoutes()
}
