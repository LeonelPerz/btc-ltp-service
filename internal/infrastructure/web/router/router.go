package router

import (
	"btc-ltp-service/internal/domain/interfaces"
	"btc-ltp-service/internal/infrastructure/config"
	"btc-ltp-service/internal/infrastructure/logging"
	"btc-ltp-service/internal/infrastructure/metrics"
	"btc-ltp-service/internal/infrastructure/ratelimit"
	"btc-ltp-service/internal/infrastructure/web/handlers"
	"btc-ltp-service/internal/infrastructure/web/middleware"
	"context"
	"net/http"

	_ "btc-ltp-service/docs" // Import docs for swagger

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	httpSwagger "github.com/swaggo/http-swagger"
)

// Router encapsulates route configuration
type Router struct {
	priceService    interfaces.PriceService
	supportedPairs  []string
	rateLimitConfig config.RateLimitConfig
	authConfig      config.AuthConfig
}

// NewRouter creates a new router instance
func NewRouter(priceService interfaces.PriceService, supportedPairs []string, rateLimitConfig config.RateLimitConfig, authConfig config.AuthConfig) *Router {
	return &Router{
		priceService:    priceService,
		supportedPairs:  supportedPairs,
		rateLimitConfig: rateLimitConfig,
		authConfig:      authConfig,
	}
}

// SetupRoutes configures all application routes
func (r *Router) SetupRoutes() http.Handler {
	// Create main router
	mainRouter := mux.NewRouter()

	// Create handlers
	ltpHandler := handlers.NewLTPHandler(r.priceService, r.supportedPairs)
	healthHandler := handlers.NewHealthHandler(r.priceService)

	// Swagger UI documentation (without rate limiting)
	// Swagger UI at "/swagger/". Serves `doc.json` generated by swag.
	mainRouter.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // Specification
	)).Methods("GET")

	// Legacy redirect: /docs -> /swagger/index.html
	mainRouter.HandleFunc("/docs", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/swagger/index.html", http.StatusMovedPermanently)
	}).Methods("GET")

	// Prometheus metrics endpoint (without rate limiting)
	mainRouter.Handle("/metrics", promhttp.Handler()).Methods("GET")

	// Health checks (without rate limiting)
	mainRouter.HandleFunc("/health", healthHandler.Health).Methods("GET")
	mainRouter.HandleFunc("/ready", healthHandler.Ready).Methods("GET")

	// Create a separate subrouter for API endpoints (not using PathPrefix on mainRouter)
	apiRouter := mux.NewRouter()

	// LTP endpoints on the separate router
	apiRouter.HandleFunc("/ltp", ltpHandler.GetLTP).Methods("GET")
	apiRouter.HandleFunc("/ltp/refresh", ltpHandler.RefreshPrices).Methods("POST")
	apiRouter.HandleFunc("/ltp/cached", ltpHandler.GetCachedPrices).Methods("GET")

	// Apply middlewares by layer:
	// 1. Auth middleware (if enabled) - applied to API routes before rate limiting
	// 2. Rate limiting - applied to API routes only
	// 3. Global middlewares - applied to everything

	// Prepare API router with Auth middleware (if enabled)
	var finalAPIRouter http.Handler = apiRouter
	if r.authConfig.Enabled {
		// Debug log para verificar la configuraci√≥n de auth
		logging.Info(context.Background(), "Applying auth middleware to API routes", logging.Fields{
			"enabled":      r.authConfig.Enabled,
			"api_key_set":  r.authConfig.APIKey != "",
			"header_name":  r.authConfig.HeaderName,
			"unauth_paths": r.authConfig.UnauthPaths,
		})
		authMiddleware := middleware.NewAuthMiddleware(r.authConfig)
		finalAPIRouter = authMiddleware.Handler(apiRouter)
	} else {
		logging.Info(context.Background(), "Auth middleware disabled", nil)
	}

	// Apply rate limiting to the (potentially auth-wrapped) API router
	rateLimitMiddleware := ratelimit.NewRateLimitMiddlewareWithConfig(r.rateLimitConfig)
	rateLimitedAPIRouter := rateLimitMiddleware.Handler(finalAPIRouter)

	// Mount the fully wrapped API router to the main router
	mainRouter.PathPrefix("/api/v1").Handler(http.StripPrefix("/api/v1", rateLimitedAPIRouter))

	// Apply global middlewares to the entire router
	handler := middleware.RequestTracingMiddleware(mainRouter)
	handler = metrics.HTTPMetricsMiddleware(handler)
	handler = middleware.LoggingMiddleware(handler)
	handler = middleware.CORSMiddleware(handler)

	return handler
}

// GetHandler returns the configured HTTP handler
func (r *Router) GetHandler() http.Handler {
	return r.SetupRoutes()
}
